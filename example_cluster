#!/usr/bin/env python
"""
Main entry point for running the database query processor.
Run this script to process natural language queries.
"""

import argparse
import json
import os
import sys
import time

# Import the optimized query processor
from optimized_schema_graph import OptimizedQueryProcessor

def process_interactive(processor):
    """Run an interactive session with the query processor."""
    print("\n======= Database Query Processor =======")
    print("Type 'exit' or 'quit' to end the session")
    print("Type 'exec' before a query to execute the generated SQL\n")
    
    while True:
        try:
            user_input = input("Enter your query: ").strip()
            
            if user_input.lower() in ('exit', 'quit'):
                break
                
            execute_sql = False
            if user_input.lower().startswith('exec '):
                execute_sql = True
                user_input = user_input[5:].strip()
            
            if not user_input:
                continue
            
            # Process the query
            start_time = time.time()
            results = processor.process_query(user_input)
            processing_time = time.time() - start_time
            
            # Print results
            print(f"\nQuery processed in {processing_time:.2f} seconds")
            print(f"Decomposed into {len(results['subqueries'])} subqueries:")
            
            for j, subquery_result in enumerate(results['subquery_results']):
                print(f"\n  {subquery_result['subquery_id']}: '{subquery_result['subquery_text']}'")
                
                # Print paths
                if subquery_result['top_paths']:
                    print(f"  Found {len(subquery_result['top_paths'])} relevant paths:")
                    for k, path in enumerate(subquery_result['top_paths'][:3]):
                        print(f"    Path {k+1}: {path}")
                    
                    if len(subquery_result['top_paths']) > 3:
                        print(f"    ... and {len(subquery_result['top_paths'])-3} more paths")
                else:
                    print("  No relevant paths found.")
                
                # Print generated SQL
                if subquery_result['sql_statements']:
                    print(f"  Generated {len(subquery_result['sql_statements'])} SQL statements:")
                    for k, sql in enumerate(subquery_result['sql_statements']):
                        print(f"    SQL {k+1}: {sql}")
                    
                    # Execute SQL if requested
                    if execute_sql and subquery_result['sql_statements']:
                        print("\n  Executing SQL:")
                        for k, sql in enumerate(subquery_result['sql_statements']):
                            print(f"\n    Executing SQL {k+1}:")
                            print(f"    {sql}")
                            
                            query_results = processor.execute_sql(sql)
                            if "error" in query_results:
                                print(f"    Error: {query_results['error']}")
                            else:
                                print(f"    Results: {len(query_results['rows'])} rows")
                                if query_results['rows']:
                                    print(f"    Columns: {', '.join(query_results['columns'])}")
                                    for row_idx, row in enumerate(query_results['rows'][:5]):
                                        print(f"    Row {row_idx+1}: {row}")
                                    if len(query_results['rows']) > 5:
                                        print(f"    ... and {len(query_results['rows'])-5} more rows")
                else:
                    print("  No SQL statements generated.")
            
            print("\n" + "="*50 + "\n")
            
        except KeyboardInterrupt:
            print("\nSession terminated by user.")
            break
        except Exception as e:
            print(f"Error: {str(e)}")

def process_file(processor, input_file, output_file=None):
    """Process queries from a file."""
    try:
        with open(input_file, 'r') as f:
            queries = f.readlines()
        
        results = []
        for query in queries:
            query = query.strip()
            if not query or query.startswith('#'):
                continue
                
            print(f"Processing: {query}")
            query_result = processor.process_query(query)
            results.append(query_result)
        
        if output_file:
            with open(output_file, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"Results saved to {output_file}")
            
        return results
    
    except Exception as e:
        print(f"Error processing file: {str(e)}")
        return None

def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Process natural language database queries')
    parser.add_argument('--db', '-d', required=True, help='Path to SQLite database file')
    parser.add_argument('--query', '-q', help='Single query to process')
    parser.add_argument('--input', '-i', help='Input file with one query per line')
    parser.add_argument('--output', '-o', help='Output file for results (JSON format)')
    parser.add_argument('--execute', '-e', action='store_true', help='Execute the generated SQL')
    args = parser.parse_args()
    
    # Check if database exists
    if not os.path.exists(args.db):
        print(f"Error: Database file '{args.db}' not found.")
        return 1
    
    # Initialize the query processor
    print(f"Initializing query processor with database: {args.db}")
    start_time = time.time()
    processor = OptimizedQueryProcessor(args.db)
    print(f"Initialization completed in {time.time() - start_time:.2f} seconds\n")
    
    # Process based on input type
    if args.query:
        # Process single query
        results = processor.process_query(args.query)
        for subquery_result in results['subquery_results']:
            print(f"\n{subquery_result['subquery_id']}: {subquery_result['subquery_text']}")
            
            if subquery_result['sql_statements']:
                for i, sql in enumerate(subquery_result['sql_statements']):
                    print(f"\nSQL {i+1}:")
                    print(sql)
                    
                    if args.execute:
                        print("\nExecuting SQL:")
                        query_results = processor.execute_sql(sql)
                        if "error" in query_results:
                            print(f"Error: {query_results['error']}")
                        else:
                            print(f"Found {len(query_results['rows'])} rows")
                            if query_results['rows']:
                                print(f"Columns: {', '.join(query_results['columns'])}")
                                for row in query_results['rows'][:5]:
                                    print(row)
        
        if args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            print(f"\nResults saved to {args.output}")
    
    elif args.input:
        # Process queries from file
        process_file(processor, args.input, args.output)
    
    else:
        # Interactive mode
        process_interactive(processor)
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
